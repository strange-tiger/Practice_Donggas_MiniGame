# 선형 리스트와 연결 리스트는 무엇인가?

선형 리스트는 같은 형식의 데이터를 연속되는 메모리에 순차적으로 나열, 저장하는 자료구조로, 임의 접근이 가능하다. 
대표적으로 배열이 있다.
연결 리스트는 데이터를 저장하는 각 노드가 다음 노드를 가리키는 포인터(링크)를 저장하여 데이터끼리 비 순차적으로 연결하여 저장하는 자료구조로, 임의 접근이 불가능하다. 
큐, 스택 등 다른 자료구조의 기반이 된다.

## 선형 리스트와 연결 리스트의 차이는 무엇인가?

선형 리스트는 원소가 연속적으로 저장되어 있어 임의 접근이 가능해, 각 원소의 위치를 찾아 읽기 쉽다. 
다만 실행 전에 미리 사용 메모리의 크기를 정해야 하는 정적 메모리 할당 방식을 사용하여, 저장공간 사용이 비효율적이다.
또한 리스트 내에 어떤 원소를 삽입하거나 삭제하는 경우, 그에 맞춰 리스트 내부의 다른 원소도 모두 이동하고 정렬해야 하기에 비효율적이다.
Big-O 표기법으로 표기하자면, 읽기는 임의 접근으로 O(1), 검색은 하나하나 비교해야 하기에 O(n)(다만 정렬되어 있고 이진 검색이 가능하면 O(logn)), 삽입은 모든 데이터를 이동해야 하기에 O(n)(맨 끝이면 O(1)), 삭제 또한 같은 이유로 O(n), 맨끝이면 O(1)의 시간이 걸린다.

연결 리스트는 원소가 비연속적으로 저장되어 있기에 임의 접근이 불가능하고, 처음과 끝의 원소가 아닌 이상 경로를 따라가며 하나하나 읽어나가야 하기에 읽기에는 비효율적이다.
다만 비연속적으로 저장되어 있기에 할당하는 메모리를 허용하는 만큼 동적으로 늘릴 수 있다. 그만큼 효율적으로 메모리를 사용할 수 있으나, 링크를 저장하기에 선형 리스트에 비해 추가 메모리가 필요하다.
또한 원소를 삽입하고 삭제할 때 다른 원소의 이동이 필요 없어 편리하다.
Big-O 표기법으로 표기하자면, 읽기는 임의 접근이 불가해 링크를 따라 찾아야 하므로 O(n), 검색은 하나하나 비교해야 하기에 O(n)(이진 검색도 불가), 삽입은 해당 위치까지 이동해야 하기에 O(n)(처음과 맨 끝이면 O(1)), 삭제 또한 같은 이유로 O(n), 처음이나 맨끝이면 O(1)의 시간이 걸린다.

# 트리란 무엇인가?

그래프의 일종으로, 1개 이상의 노드가 나무의 가지처럼 계층적 구조로 연결되어 있는 계층형 자료구조이다. 
데이터가 저장된 노드와 노드 간 관계를 표현하는 간선으로 구성된다.
데이터 사이의 포함 관계, 계층 관계 등을 나타내기 위해 사용된다.

## 이진 탐색 트리란 무엇인가?

검색, 삭제, 삽입, 정렬 등 자료의 관리를 효율적으로 하기 위해 이진 검색처럼 노드를 크기 순으로 정렬하여 놓은 이진 트리이다.
예를 들어, 이진 탐색 트리의 어떤 노드든지 한 노드를 고르면 그 왼쪽 서브트리 및 노드에는 모두 그 노드의 값보다 작은 값을 갖는 노드들이 있고, 오른쪽 서브트리 및 노드에는 큰 값을 갖는 노드들이 있다. 여기서 각 서브트리는 다시 이진 탐색 트리이다.
이진 트리란, 차수가 2 이하인 트리이다.
BST(Binary Search Tree)라고도 불린다.

## 힙이란 무엇인가?

노드 중 값이 가장 큰 노드(최대 원소)나 가장 작은 노드(최소 원소)를 찾기 쉽게 만들어진 완전 이진 트리. 최대 원소를 찾기 위한 건 최대 힙, 최소 원소를 찾기 위한 건 최소 힙이라 한다.
완전 이진 트리란 마지막 레벨을 제외한 각 레벨에 노드가 꽉 차있는 이진 트리를 말한다.
힙이 되기 위한 조건이 두 가지 있는데, 하나는 찾고자 하는 노드(최대 혹은 최소 원소)에 즉각적으로 접근이 가능해야 한다는 것이다. 
보통 루트 노드는 바로 접근이 가능하기에, 최대/최소 원소는 항상 루트 노드에 존재한다.
둘째는 부모 노드가 자식 노드보다 항상 우선해야 한다는 것이다. 
최대 힙이면 부모 노드가 자식 노드보다 항상 크고, 최소 힙이면 항상 작다.

# DFS와 BFS는 무엇인가?

탐색이란 그래프의 한 노드에서 시작해 그래프에 있는 모든 노드를 최소 한 번은 읽는 것(방문)을 말한다.
DFS(Depth First Search, 깊이 우선 탐색)은 한 루트로 할 수 있는 한 탐색하다가 더 이상 방문할 수 있는 노드가 없다면 되돌아와서 다른 루트로 방문하지 않은 노드를 탐색하는 방법이다. 
스택을 사용하여 구현한다.
BFS(Breadth First Search, 너비 우선 탐색)은 시작점에서부터 현재 노드에 인접한 노드를 모두 방문한 후, 그 다음 인접 노드로 이동해 그 노드의 인접 노드를 모두 방문하는 방법이다.
큐를 사용하여 구현한다.

## 트리에 DFS와 BFS를 했을때 결과에 어떤 차이가 있는지 예시를 들어보며 작성해보아라

예를들어 다음과 같은 트리가 있을 때, DFS와 BFS는 각각 다음과 같이 결과를 낸다.
    A
   / \
  B   C
 / \   \
D   E   F

DFS : A - B - D - E - C - F
BFS : A - B - C - D - E - F

이때 DFS는 D에 도달하기까지 A-B-D의 한 경로만 기억하면 됐지만, BFS는 A-B, A-C로 다른 경로까지 기억해야 한다.
더군다나 지금은 트리의 차수가 2이지만, 만약 더 큰 차수의 트리였다면 D에 도달하기까지 DFS가 세 개의 노드를 방문하는 동안 BFS는 무수히 많은 차수만큼 더 방문하고 D에 도달할 수 있었을 것이다.
하지만 C에 도달하고 싶은데 D에서 끊임없이 더 이어지는 트리였다면, BFS가 C에 빨리 도달하는 동안 DFS는 깊이 빠져버려 도달할 수 없었을 것이다.
또한 DFS는 위 예시에서처럼 한 경로만을 기억하기에, BFS와 달리 최단 경로를 찾기 힘들다.
정리하자면,

- DFS
    - 장점
        1. 현재 경로의 노드만 기억하면 되어 메모리 소비가 적다.
        2. 깊은 단계에 있는 노드의 경우 찾기에 비교적 쉽다.
    - 단점
        1. 탐색 중 너무 깊이 빠져버려 시간이 걸릴 수 있다.
        2. 최단 경로를 찾기 힘들다.
- BFS
    - 장점
        1. 아무리 경로가 길어도 목표와 다른 경로에 깊이 빠지지 않는다.
        2. 최단 경로를 찾을 수 있다.(가중치가 없는 경우)
    - 단점
        1. 여러 경로를 같이 기억해야 하기에 비교적 메모리 소비가 있다.
        2. 깊은 단계에 있는 노드는 그 노드 이전 단계의 노드를 모두 방문해야 하기에 시간이 걸릴 수 있다.

# 그래프란 무엇인가?

자료 간 관계에 특화되어 이를 보이는 자료구조이다. 정점과 간선으로 구성되어 있으며, 정점은 고유하게 식별되는 객체고 간선은 정점 간 관계를 나타낸다.

# 해시 테이블은 무엇인가?

연관 배열이라고도 한다. 검색을 위해 해싱을 활용해 데이터를 저장하는 자료구조이다. 
해싱을 통해 구한 해시값을 선형 리스트와 같이 인덱스로 활용하여 임의 접근이 가능하다. 즉, 해시값을 키로 하여 키와 값을 쌍으로 하여 갖는 리스트이다.

## 해싱은 무엇인가?

임의의 길이를 갖는 임의의 데이터를 고정된 길이의 데이터로 변환하는 것을 의미한다. 이때 사용하는 함수를 해시 함수, 혹은 짧게 해시라고 한다.

# 참조
- [자료구조와 알고리즘 with STL](https://docs.google.com/document/d/1wUms27Vj8si-jEjfRQJwSvsQ2CJNCv4IU6GOtesY4TE/edit#heading=h.5ik99qqlfkf9)
- [정보통신기술용어해설 : Linear List 선형 리스트](http://www.ktword.co.kr/test/view/view.php?m_temp1=6281)
- [정보통신기술용어해설 : Linked List 연결 리스트, 링크드 리스트](http://www.ktword.co.kr/test/view/view.php?no=3559)
- [정보통신기술용어해설 : Tree 트리](http://www.ktword.co.kr/test/view/view.php?no=1332)
- [정보통신기술용어해설 : BST Binary Search Tree 이진 탐색 트리](http://www.ktword.co.kr/test/view/view.php?no=6126)
- [Wikipedia : 이진 탐색 트리](https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A7%84_%ED%83%90%EC%83%89_%ED%8A%B8%EB%A6%AC)
- [정보통신기술용어해설 : Heap, Binary Heap 힙, 이진 힙](http://www.ktword.co.kr/test/view/view.php?m_temp1=6106&id=1303)
- [정보통신기술용어해설 : DFS Depth First Search 깊이 우선 탐색](http://www.ktword.co.kr/test/view/view.php?no=6391)
- [정보통신기술용어해설 : BFS Breadth First Serach 너비 우선 탐색](http://www.ktword.co.kr/test/view/view.php?no=6392)
- [나무위키 : 깊이 우선 탐색](https://namu.wiki/w/%EA%B9%8A%EC%9D%B4%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89)
- [나무위키 : 너비 우선 탐색](https://namu.wiki/w/%EB%84%88%EB%B9%84%20%EC%9A%B0%EC%84%A0%20%ED%83%90%EC%83%89)
- [나무위키 : 해시](https://namu.wiki/w/%ED%95%B4%EC%8B%9C)