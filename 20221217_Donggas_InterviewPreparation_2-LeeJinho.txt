# 가상 함수는 무엇이고 어떻게 동작하는가?
가상 함수는 다형성을 지원하기 위한 기능으로, 파생 클래스에서 재정의할 것으로 기대하고 정의된다. 
정의할 때 메소드 앞에 virtual 한정자가 들어간다.
일반 함수는 컴파일 시 함수의 호출을 결정하는 정적 바인딩(Static Binding)인 반면, 가상 함수는 런타임에 함수의 호출을 결정하는 동적 바인딩(Dynamic Binding)으로 동작한다. 
이때 가상 함수의 주소를 저장하는 가상 함수 테이블이 각 타입마다 존재하고, 인스턴스마다 자기 타입의 가상 함수 테이블을 가리키는 가상 함수 포인터를 갖는다.

## 오버로딩과 오버라이딩의 차이점은 무엇인가?
오버로딩은 함수 호출을 컴파일할 때, 같은 식별자의 함수라도 매개변수가 다르게 하여 여러 구현을 호출할 수 있도록 하는 기능이다.
오버라이딩은 파생 클래스에서 가상 함수의 내용을 재정의하는 것을 의미한다.

# 델리게이트는 무엇인가?
대리자라고도 하며, 함수에 대한 참조로서 콜백을 맡아 실행한다.

# 델리게이트와 함수 포인터의 차이점은 무엇인가?
함수 포인터는 한 메소드의 주소를 가리키지만, 대리자는 내부적으로 가리키는 객체의 주소와 메소드의 주소를 함께 갖고 있어, 정적 메소드와 인스턴스 메소드를 가리지 않고 다룰 수 있다.
또한, 함수 포인터는 메소드를 가리킬 때 한 타입에 대해서만 사용할 수 있지만 대리자는 여러 타입의 메소드를 참조할 수 있다.
추가로 함수 포인터는 한번에 하나의 메소드만 가리킬 수 있지만 대리자는 한번에 여러 메소드를 참조할 수 있다.

# 이벤트란 무엇인가?
대리자의 일종으로, 옵저버 패턴을 사용하기 쉽게하기 위해 구현된 기능이다. 객체의 상태 변화를 다른 객체(구독자)에게 알리기 위해 사용된다.

# 델리게이트와 이벤트의 차이점은 무엇인가?
이벤트는 델리게이트와 달리 한정자와 상관없이 선언된 객체의 외부에서 직접 사용(호출, 발생)할 수 없다.
그 이유는 객체 내부에서만 그 상태 변화를 알릴 수 있도록 하여, 견고한 이벤트 기반 프로그래밍을 가능하게 하기 위함이다.

# 프로퍼티란 무엇인가?
객체의 데이터가 오염되는 것을 막기 위해 클래스 내부의 필드를 감추고, 그러면서 사용이 편리하게 하기 위해 Get / Set 메소드를 대체한 기능이 프로퍼티이다.
프로퍼티는 필드와 메소드의 측면을 결합한다. 그렇기에 프로퍼티는 변수로 분류되지 않는다.
get, set, init 접근자를 사용해, 읽기 전용으로 만드는 등 용도를 결정할 수 있다.

# 리플렉션이란 무엇인가?
동적으로 객체의 타입 정보를 알 수 있는 기능이다. 
런타임에서 객체의 타입 이름, 프로퍼티, 메소드, 필드, 이벤트 목록 등 정보를 얻을 수 있으며, 이를 바탕으로 동적으로 인스턴스를 생성하고 메소드를 호출하거나 필드, 프로퍼티에 접근할 수도 있다. 

# 어트리뷰트란 무엇인가?
코드에 대한 부가 정보(메타데이터, 선언적 정보)를 기록하고 연결하여 읽을 수 있도록 하는 기능이다. 
어트리뷰트는 프로그램에 메타데이터를 추가할 수 있다.
여기서 메타데이터란 프로그램에 정의된 형식에 대한 정보로, 간단히 데이터의 데이터라 할 수 있다. 예를들면 코드 자체에 대한 데이터가 있겠다.

# 제네릭이란 무엇인가?
일반화 프로그래밍을 지원하기 위한 기능으로서, 클래스 또는 메소드가 선언되고 인스턴스화될 때까지 형식 매개변수로 하나 이상의 형식을 구현하는 클래스 및 메소드를 디자인할 수 있도록 지원하는 기능이다.
C++의 템플릿과 달리 제네릭은 런타임에 특수화된 타입이 만들어진다.

# 박싱과 언박싱이 무엇인가?
박싱은 값 형식이 참조 형식 또는 구현하는 인터페이스 중 하나로 캐스팅될 때 값 형식을 변환하는 프로세스이며, 이때 CLR은 값 형식의 값을 object 형식 새로운 인스턴스를 생성해 힙메모리에 복사한다. 
언박싱은 박싱된 인스턴스에서 값 형식으로 다시 캐스팅될 때 값 형식을 추출하는 프로세스이다. 이때 힙메모리에서 스택메모리로 값이 복사된다.
박싱은 암시적으로 이루어지며, 언박싱은 명시적으로 이루어진다.