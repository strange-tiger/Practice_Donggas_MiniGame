# 값타입과 참조타입이란 무엇인가?
CTS에서 제공하는 타입의 두 종류.
값타입은 스택메모리에 할당되고 가비지 수집이 이루어지지 않으며, 
참조타입은 힙메모리에 할당되고 가비지 수집이 이루어진다.

## C#에서 CTS는 무엇인가?
CTS란 Common Type System (공용 타입 시스템)의 준말로, 
.NET에서 C#을 포함한 여러 .NET 기반 언어를 지원하기 위해 
제공하는 시스템이다.
CTS에서 제공하는 모든 형식은 기본 타입인 System.Object에서 파생되고 
이는 값타입(Value Type)과 참조타입(Reference Type)으로 구분된다.

## C#에서 값타입과 참조타입엔 무엇이 있는가?
C#에서 값타입은 구조체(Struct), 열거형(Enumeration), 
기본 제공 타입(int, float, double 등)이 있다.
참조타입은 클래스(Class), 대리자(Delegate), 속성(Attribute), 
배열(Array), 리스트 등의 컬렉션(Collection) 등이 있다.

## C#에서 struct와 class의 차이는 무엇인가?
struct는 값타입, class는 참조타입으로 대부분의 차이는 
값타입과 참조타입의 차이와 같다.
struct는 스택메모리에 할당되고 가비지 수집이 이루어지지 않는다. 
class는 힙메모리에 할당되고 가비지 수집이 이루어진다.
또한 내부의 배열 요소에도 차이가 있어, struct의 배열 요소는 
실제 값 형식 인스턴스이고 class의 배열 요소는 참조 형식 인스턴스에 
대한 참조이다.
위와 같은 차이에서 일반적으로 struct의 할당 및 할당 취소가 
class의 그것보다 저렴하게 된다.
다만 struct는 캐스팅 될 때 Boxing과 Unboxing이 일어나고 
class는 일어나지 않아, 자주 캐스팅되는 객체는 class 형식으로 
정의하는 편이 좋다.
또한 할당 방식에서도 차이가 있는데, struct와 같은 값타입의 할당은 
전체 값을 복제하고 class와 같은 참조타입은 참조만을 복사하기에 
크기가 큰 객체의 경우 class가 struct보다 할당하기 좋다.

# Call by value와 Call by reference는 무엇인가?
함수에 값을 인자로 전달하는 방식의 종류이다.
Call by value는 함수에 값을 복사해 전달하는 방식으로, 이때 전달된 
인자는 함수의 매개변수로 복사된다. 이 매개변수는 인자와 별개의 
변수이므로 원래 변수에는 영향을 미치지 않는다.
Call by reference는 함수에 변수의 주소값을 전달하는 방식이다.
이때 전달된 인자로 변수에 접근하면 원래 변수에 접근해 영향을 
미칠 수 있다. 함수를 실행해 인자를 수정하고 싶으면 사용할 수 있는 
방법이다.

## 값복사란 무엇인가?
값타입의 객체를 그대로 복사해 새로운 값타입 객체를 만드는 것을 
의미한다.

# 힙메모리와 스택메모리는 무엇인가?
운영체제에서 프로세스에 제공하는 메모리 공간은 
코드 / 데이터 / 힙 / 스택의 네 영역으로 구분된다.
힙메모리와 스택메모리는 동적메모리로, 힙메모리는 그 중 동적 할당을 
받는 영역이고, 스택메모리는 그 중 지역 변수 등 함수 호출 시 필요한 
데이터를 할당 받는 영역이다.
동적 할당은 런타임 단계에서 이루어지는 할당을 의미한다.

## 힙메모리와 스택메모리의 차이점은 무엇인가?
힙메모리는 동적 할당을 받고, 선입선출(First-In First-Out; FIFO) 
방식을 따른다. 
가비지 컬렉터가 없는 이상 사용자가 직접 할당과 해제를 수행해야 한다. 
그 크기는 런타임에서 정해지기에 프로그램 실행 중에도 바꿀 수 있다.
스택메모리는 정적 할당을 받고, 후입선출(Last-In First-Out; LIFO) 
방식을 따른다.
함수 호출 시에 필요한 데이터(지역변수, 매개변수, 리턴값 등)가 
할당되고 함수가 종료되면 제거한다.
그 크기는 컴파일에서 정해지기에 프로그램 실행 중에 바꿀 수 없고 
무한히 할당할 수 없다.

## C++에서 int* pA = new int; 라고 작성했을 때, x86 아키텍처 기준 힙메모리엔 몇 바이트가 할당되고 스택메모리엔 몇 바이트가 할당되는가? 어떤 순서로 할당이 되는가?
스택메모리에 포인터 주소값 4바이트가, 
힙메모리에 int타입 크기 4바이트가 할당된다.
new 연산자는 힙메모리에 값을 할당하고 그 주소값을 반환하기에, 
힙메모리에 먼저 int 값이 할당되고 스택메모리에 포인터 주소값이 
할당된다.

## 메모리 파편화란 무엇인가?
메모리의 빈 공간이 여러 군데로 나뉘어져 메모리를 전부 사용하지 
않았음에도 요청된 만큼의 단일 메모리 블록이 없어 더 이상 할당할 수 
없게 되는 상태를 일컫는 말이다.

## 메모리 파편화는 어떤 문제를 초래하는가?
프로세스가 실제 필요한 양보다 더 많은 메모리를 할당하게 되고 그만큼 
메모리 낭비가 일어나게 된다.

# 메모리 누수란 무엇인가?
동적 할당으로 메모리를 할당한 후 더 이상 사용하지 않아도 해제를 
하지 않은 것을 일컫는 말이다.
이로 인해 누수된 만큼의 메모리를 해제할 때까지 사용할 수 없어 낭비가 
일어난다.

## C#에서 가비지 컬렉터란 무엇인가?
프로그래머가 직접 동적 할당된 메모리를 관리하는데 있어서 
위 메모리 누수를 포함해 이미 해제된 메모리를 또 해제하거나, 
사용이 끝나지 않은 메모리를 섣불리 해제하는 등의 문제가 발생하였다.
이를 해결하기 위해 자동으로 메모리를 관리하는 가비지 컬렉터가 나오게 
되었다.
가비지 컬렉터는 더 이상 사용하지 않는 메모리를 의사적으로 판별해 
해제하고 재사용 가능하도록 만든다. 여기서 각 메모리의 사용 여부는 
정지 문제(Halting Problem)로 인해 정확히 판별이 불가하여, 
다음 두 가지 방법을 사용해 의사적으로 판별한다.
첫째로 추적 가비지 수집을 사용한다. 첫 시작점 루트에서 각 메모리까지 
도달할 수 있는지를 살펴, 도달하지 못하는 메모리는 가비지 수집 
대상으로 가정한다.
둘째로 참조 카운팅을 사용한다. 각 메모리를 참조하는 메모리를 세어, 
참조하는 메모리가 없는 경우 가비지 수집 대상으로 가정한다.

## C#에서 가비지 컬렉터는 어떻게 동작하는가?
C#의 가비지 컬렉터는 세대별 가비지 수집 방식을 활용하며, 
이는 추적 가비지 수집을 사용한다. 
가비지 컬렉터가 관리하는 메모리를 매니지드 힙이라 하며, 
매니지드 힙은 가비지 컬렉터의 성능을 최적화하고 메모리를 재사용하기 
용이하게 하기 위해 객체의 수명에 따라 0세대, 1세대, 2세대의 3개 
세대로 나뉜다. 이는 다음 3가지 사항을 기반으로 한다.
첫째, 가비지 수집은 매니지드 힙 전체가 대상일 때보다 일부에서 
이루어질 때 더 빠르다.
둘째, 최신 객체일수록 수명이 짧고 이전 객체일수록 수명이 길다.
셋째, 최신 객체끼리 서로 연관되는 경향이 있어 캐싱에 좋다.
이에 따라 일부 세대만 압축하고 할당, 해제할 수 있어 좋다.
0세대에는 최신 객체를 할당한다. 그렇기에 메모리 할당은 0세대에서만 
일어나고, 그래서 가비지 수집은 0세대에서 가장 자주 발생한다.
0세대가 가득차면 공간을 확보하는 가비지 수집을 수행하고, 메모리를 
압축한 후 1세대로 승격한다. 
똑같이 1세대에서 가비지 수집이 완료되어도 메모리 압축 후 2세대로 
승격한다.
다만 주의해야할 점은 가비지 수집 자체가 자원을 많이 쓰는 연산이며, 
멀티스레드 환경에서 가비지 수집이 일어나고 있는 스레드를 제외한 
모든 스레드가 일시 중단된다는 것이다.

## 유니티에서 가비지 컬렉터는 어떻게 동작하는가?
유니티의 가비지 컬렉터는 Boehm–Demers–Weiser 가비지 컬렉터를 
사용하며, 이는 점진적 가비지 수집 방식을 사용할 수 있다.
점진적 가비지 수집 방식은 가비지 수집을 위해 스레드를 중단하지 않고 
작업량을 여러 프레임에 걸쳐 분할함으로써 가비지 컬렉터로 인한 중단의 
영향을 최소화한다.